\section{Analysis tasks}
\label{sec:analysis-tasks}

In this section, we study a range of fundamental analysis tasks, namely function reconstruction
(Section~\ref{sec:rmse-optimized}), gradient computation (Section~\ref{sec:gradient}), Laplacian
computation (Section~\ref{sec:laplacian}), histogram computation (Section~\ref{sec:histogram}), and
isocontour extraction (Section~\ref{sec:isocontour}). For each task, we define an error metric $E$
(see Section~\ref{sec:data_dep_streams}) that is the basis for evaluating a stream's performance.
Algorithm~\ref{alg:greedy} is used to compute a greedy stream optimized for the task at hand, in
terms of minimizing the relevant $E$ at every point. Each analysis task potentially requires a
fundamentally different stream for optimal results. Therefore, the goal is to distill the core
characteristics of these optimized streams. To accomplish this goal, we define and make use of a
concept named \emph{stream signature} (Section~\ref{sec:stream-signature}). The signature of a
stream is a small matrix that encodes the stream's ``preferences'' in terms of
precision-versus-resolution tradeoffs. As such, the signature not only reveals the characteristics
of a stream, but can also be used in practice to ``steer'' streaming in a way that is optimized for
the task at hand.

\subsection{Stream signatures}
\label{sec:stream-signature}

To analyze the core characteristics of a stream, we introduce the concept of a \emph{stream
signature}. A signature is a $\bar{l} \times \bar{b}$ matrix, with $\bar{b}$ being the number of bit
planes, and $\bar{l}$ the number of wavelet subbands. The $(l,b)$ element of the matrix is
associated with chunks belonging in subband $l$ and bit plane $b$ , and contains an integer value in
the range $[0,\bar{b}\times \bar{l})$. This value indicates, on average, the position in which
chunks associated with that element appear in the stream, relative to chunks associated with other
elements. For example, the signature  $A=\bigl[
\begin{smallmatrix}0 & 1 & 4\\ 2 & 3 & 5\end{smallmatrix}\bigr]$ conveys the information that the
most important chunks lie on the first bit plane of the first subband ($A(0,0)=0$), followed by
chunks lying on the second bit plane of the first subband ($A(0,1)=1$), then the first bit plane of
the second subband ($A(1,0)=2$), and so on.

To compute a stream signature, we partition the whole domain into several \emph{regions}, compute
one signature per region, then sum all the per-region signatures. Partitioning is needed since it is
only meaningful to compute the relative ordering of chunks if they come from the same (``small''
enough) region. For example, a chunk at one corner of the domain can be streamed before another
chunk at an opposite corner, but this fact contains no useful information. We want a region to be as
small as possible, and define a region to be the spatial volume/area that is covered by a chunk in
the coarsest subband. So, the total number of regions, $\bar{r}$, is the same as the number of
chunks in the coarsest subband. Note that regions exist in the global domain, as they are not
confined to individual subbands. Ideally, the global signature should retain information from all
the per-region signatures, but due to space constraints, we have chosen to condense all the local
signatures by summing them into one signature. This choice results in signatures that are less
meaningful for data that contains a high degree of spatial variability. We have found, however, that
this choice works well for the various data sets used in this paper. If signatures are deemed useful
enough to be deployed in practice, a more sophisticated ``compression'' of the signature stack might
be necessary for the best results. Algorithm~\ref{alg:signature} lists the steps in detail.

\begin{algorithm}[h]
  \caption{Computing a stream signature}
  \begin{algorithmic}[1]
    \Inputs{
			A stream $C=\{c_i\}, i\in\{0,\dots,n-1\}$\\}
		\Initialize{Per-region signature matrix $A_r\gets 0, r\in\{0,\dots\bar{r}-1\}$\\
		Global signature matrix $A \gets 0$}
		\For{each chunk $c_i$}
			\State Let $r$, $b$, $l$ be the region, bit plane, and subband that $c_i$ belongs
			\State $A_r(l,b) \gets A_r(l,b)+i$
		\EndFor
		\For{each region $r$}
			\State Sort the elements of $A_r$
			\State Assign each element of $A_r$ its index after sorting
			\State $A \gets A+A_r$
		\EndFor
		\State Sort the elements of $A$
		\State Assign each element of $A$ its index after sorting
		\Output{The signature matrix $A$}
	\end{algorithmic}
	\label{alg:signature}
\end{algorithm}

Figure~\ref{fig:signature-static} shows renderings of signatures for the three static streams:
\emph{by bit plane}, \emph{by level}, \emph{by wavelet norm}. Each signature is shown as an image of
size $\bar{b}$ (width) $\times \bar{l}$ (height). The signature's $(0,0)$ element, corresponding to
the coarsest subband and the most significant bit plane, maps to the top-left pixel of the image.
The elements' values are mapped to colors on a linear green scale, in which smaller numbers map to
brighter greens. That is, $(l,b)$ pairs that map to brighter pixels are considered more important
and thus appear earlier in stream.

A signature can be used to construct a ``semi-static'' stream, by iterating through the elements of
the signature in ascending order, and streaming all the chunks associated with each current element.
This stream is similar to purely static streams, in the sense that the ordering of subband-bit plane
pairs is deterministic. However, it is different from purely static streams in that this
deterministic ordering must be established between the client and the server through the
transmission of the signature. Fortunately, the size of the signature is often negligible compared
to the size of the data itself. In 3D, assuming 22 subbands and 32-bit quantized coefficients, a
signature is merely $1408 (=22\times 32\times 2)$ bytes.

\subsection{Function reconstruction}
\label{sec:rmse-optimized}

The most fundamental analysis task is that of reconstructing the function itself. The most common
error metric in this case is the root-mean-square error (RMSE). For each data set, we use
Algorithm~\ref{alg:greedy} to construct an \emph{rmse-optimized} stream, and plot this stream
together with the three static streams (Section~\ref{sec:terminologies}) in
Figure~\ref{fig:rmse-optimized}. We also include \emph{rmse signature} streams, computed from the
signatures of \emph{rmse-optimized}. Note, again, that all leading-zero chunks are removed before
plotting, to emulate the effect of entropy compression often done in practice. It can be observed
that the difference between \emph{by wavelet norm} and \emph{rmse-optimized} is negligible in most
cases. This result is expected, because \emph{by wavelet norm} and \emph{rmse-optimized} both order
the chunks according to their contribution to in the $L_2$ sense, with \emph{rmse-optimized} also
taking into account the actual values of the bits. This difference has little effect, because, as
leading zero bits are removed, the rest of the bits (of the wavelet coefficients) are known to be
distributed approximately uniformly among $0$ and $1$.

\begin{figure}[h]
  \centering
	\subcaptionbox{Boiler}{
  {\includegraphics[width=0.48\linewidth]{rmse/rmse-optimized-boiler}}}
  \subcaptionbox{Diffusivity}{
  {\includegraphics[width=0.48\linewidth]{rmse/rmse-optimized-diffusivity}}}
  \subcaptionbox{Plasma}{
  {\includegraphics[width=0.48\linewidth]{rmse/rmse-optimized-plasma}}}
  \subcaptionbox{Turbulence}{
  {\includegraphics[width=0.48\linewidth]{rmse/rmse-optimized-turbulence}}}
  \caption{Root-mean-square error of reconstructed functions for the three data-agnostic streams
  defined in Section \ref{sec:motivation}, and the \emph{rmse-optimized} stream. Lower is better.
  The streams are truncated to highlight the differences, without omitting important information.
  \emph{rmse-optimized} performs best, followed closely by \emph{by wavelet norm}, \emph{rmse
  signature} and \emph{by bit plane}. TODO:explain any ``strange'' behavior in the plot.}
 	\label{fig:rmse-optimized}
\end{figure}

Among the static streams, \emph{by level} performs poorly compared to \emph{by bit plane}, \emph{by
wavelet norm}, and \emph{rmse signature}. This is because, in this case, low-ordered bits or
coarse-level coefficients contribute little compared to high-ordered bits of fine-level
coefficients. This difference in contribution is magnified when the data contains more fine-scale
features, as is the case for the \emph{plasma} data set. In Figure~\ref{fig:rmse-rendering}, we
render this field at 0.74 bits per sample (bps) for all three streams, and compare these rendering
with that of the groundtruth data. \emph{by level} results in heavy artifacts that are not seen by
\emph{by bit plane} and \emph{by wavelet norm}. \emph{by wavelet norm} performs slightly better than
\emph{by bit plane} here and in all other cases. In Figure~\ref{fig:precision-map-rmse}, it can be
observed that the distribution of bits per subband of the \emph{rmse signature} stream (and hence,
the \emph{rmse-optimized} stream) closely resembles that of \emph{by wavelet norm}. These results
suggest that in practice, \emph{by wavelet norm} is a near-optimal way to stream data that minimizes
root-mean-square errors, regardless of the data.

\begin{figure}[h]
	\centering
	\subcaptionbox{\emph{by level}}{
	{\includegraphics[width=0.31\linewidth]{rmse/rmse-boiler-level}}}
	\subcaptionbox{\emph{by bit plane}}{
	{\includegraphics[width=0.31\linewidth]{rmse/rmse-boiler-bit-plane}}}
	\subcaptionbox{\emph{by magnitude}}{
	{\includegraphics[width=0.31\linewidth]{rmse/rmse-boiler-magnitude}}}
	\subcaptionbox{\emph{by wavelet norm}}{
	{\includegraphics[width=0.31\linewidth]{rmse/rmse-boiler-wavelet-norm}}}
	\subcaptionbox{\emph{by signature}}{
	{\includegraphics[width=0.31\linewidth]{rmse/rmse-boiler-signature}}}
	\subcaptionbox{\emph{groundtruth}}{
	{\includegraphics[width=0.31\linewidth]{rmse/rmse-boiler-groundtruth}}}
	\caption{\emph{boiler} data reconstructed at 0.03 bps}
 	\label{fig:rmse-rendering}
\end{figure}
