\section{Analysis tasks}\label{sec:analysis-tasks}

In this section, we study a gamut of fundamental analysis tasks, namely function reconstruction
(\autoref{sec:rmse-optimized}), derivative computation (\autoref{sec:gradient} and
\autoref{sec:laplacian}), histogram computation (\autoref{sec:histogram}), and isocontour extraction
(\autoref{sec:isocontour}). For each task, we define an error metric $e$ that is the basis for
evaluating performance of different streams on the task. We use Algorithm~\ref{alg:greedy} to
compute a stream $s_{opt}$ that is optimized for each task. An $s_{sig}$ stream is computed from the
signature of $s_{opt}$. We compare $s_{lvl}$, $s_{bit}$, $s_{wav}$, $s_{mag}$, $s_{sig}$, and
$s_{opt}$ by plotting the error as a function of the number of packets received. To mimic the
effects of entropy compression commonly used in practice, we remove all packets that contain only
leading zero bits from each stream, before plotting. This comparison is performed on a variety of
data sets, listed in \autoref{tbl:data-sets}. \duong{add the discussion about reconstructing the
whole data at full resolution before performing any analysis task.}

\begin{table*}[t]
  \caption{Data sets used in experiments \duong{Update this table}}
  \centering
  \begin{tabular}{p{0.15\linewidth}p{0.20\linewidth}p{0.15\linewidth}p{0.10\linewidth}p{0.15\linewidth}}
  \hline
  Name & Source & Slice dimension & Type & Citation\\
  \hline
  boiler & combustion simulation& $140\times 148$ & float64 &\\
  euler & fluid simulation& $256\times 1024$ & float64 &\\
  kingsnake & CT scan & $1024\times 795$ & uint8 &\\
  plasma & magnetic reconnection simulation& $512\times 512$ & float32 &\\
  marschner-lobb & analytical function& $256\times 256$ & float64 &\\
  diffusivity & hydrodynamics simulation& $384\times 384$ & float64 &\\
  pressure & hydrodynamics simulation& $384\times 384$ & float64 &\\
  velocityz & hydrodynamics simulation& $384\times 384$ & float64 &\\
  turbulence & fluid dynamics simulation& $256\times 256$ & float32 &\\
  \hline
  \end{tabular}\label{tbl:data-sets}
\end{table*}

\subsection{Function reconstruction}\label{sec:rmse-optimized}

The most fundamental analysis task is that of reconstructing the original function itself. The most
common error metric in this case is the root-mean-square error (RMSE). The plots that compare the
streams are in \autoref{fig:rmse-optimized}. $s_{lvl}$ performs significantly worse than $s_{bit}$,
which can be attributed to the fact that $s_{bit}$ benefits more from our removal of leading zero
packets. This is because, wavelet coefficients on finer-scale subbands are relatively much smaller
in magnitude. Hence, these coefficients contain the majority of the leading zero bits, which, had
they not been removed, would have penalized $s_{bit}$ heavily, as this stream favors resolution the
most.

Since $s_{wav}$ is designed to minimize function error in $L_2$ norm, it unsurprisingly outperforms
both $s_{lvl}$ and $s_{bit}$ in terms of RMSE. In \autoref{fig:rmse-rendering} we render the
\emph{plasma} data set at 0.1 bits per sample. Bits per sample (bps) are calculated by dividing the
total size of received packets (in bits) by the total number of samples. The \duong{mention that
$s_{opt}$ gives }

\begin{figure}[h]
  \centering
	\subcaptionbox{\emph{boiler}}{ {\includegraphics[width=0.48\linewidth]{rmse/rmse-optimized-boiler}}}
		\subcaptionbox{\emph{diffusivity}}{
		{\includegraphics[width=0.48\linewidth]{rmse/rmse-optimized-diffusivity}}}
		\subcaptionbox{\emph{plasma}}{ {\includegraphics[width=0.48\linewidth]{rmse/rmse-optimized-plasma}}}
		\subcaptionbox{\emph{turbulence}}{
		{\includegraphics[width=0.48\linewidth]{rmse/rmse-optimized-turbulence}}}
		\caption{Root-mean-square error of reconstructed functions for different streams and data sets.
		Lower is better. The streams are truncated to highlight the differences, without omitting
		important information. Leading zero packets are not used for plotting. In all cases, the
		ordering of performance, from best to worst, is $s_{opt} > s_{sig} > s_{wav} > s_{bit} > s_{mag}
		> s_{lvl}$.}\label{fig:rmse-optimized}
\end{figure}

\begin{figure}[h]
	\centering
	\subcaptionbox{\emph{by level} ($s_{lvl}$)}{
	{\includegraphics[width=0.31\linewidth]{rmse/rmse-plasma-level}}} \subcaptionbox{\emph{by bit
	plane ($s_{bit}$)}}{ {\includegraphics[width=0.31\linewidth]{rmse/rmse-plasma-bit-plane}}}
	\subcaptionbox{\emph{by magnitude ($s_{mag}$)}}{
	{\includegraphics[width=0.31\linewidth]{rmse/rmse-plasma-magnitude}}} \subcaptionbox{\emph{by
	wavelet norm ($s_{wav}$)}}{
	{\includegraphics[width=0.31\linewidth]{rmse/rmse-plasma-wavelet-norm}}} \subcaptionbox{\emph{by
	signature ($s_{sig}$)}}{ {\includegraphics[width=0.31\linewidth]{rmse/rmse-plasma-signature}}}
	\subcaptionbox{\emph{reference}}{
	{\includegraphics[width=0.31\linewidth]{rmse/rmse-plasma-groundtruth}}} \caption{Volume renderings
	of \emph{plasma} at 0.1 bps. $s_{lvl}$ captures the background (purple-blue) well, while $s_{bit}$
	captures the fine details better. $s_{wav}$ combines the strength of both. $s_{sig}$ produces the
	most accurate rendering.}\label{fig:rmse-rendering}
\end{figure}
